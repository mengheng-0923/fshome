# 浏览器/js 事件循环 
同步任务：直接进入主线程放在调用栈立即执行
异步任务： 时机成熟以后放在执行对列里
执行栈清空以后就会检查任务队列
队列里的人物按照优先级依次执行
执行顺序：
首先执行宏任务的同步任务，然后执行微任务，然后就是渲染ui，再调用下一个宏任务进行执行明知道青龙任务队列的所有内容
# 异步机制
JavaScript的异步机制是一种让单线程语言能够同时处理多个任务的核心技术，它通过‌事件循环‌系统来协调任务的执行顺序，避免程序"卡死"
会限制性同步任务，异步任务挂起，等同步任务执行完以后，抽取任务对立的异步任务进行执行，知道任务队列被清空
# 浏览器的渲染机制
‌输入URL‌：
    DNS查询获取IP地址
    发起HTTP请求
    服务器返回HTML/CSS/JS资源‌
‌解析流程‌：
    HTML解析成DOM树
    CSS解析成CSSOM树
    合并DOM/CSSOM生成渲染树‌
‌渲染阶段‌：
    布局（Layout）：计算元素位置和尺寸
    绘制（Painting）：将渲染树绘制到屏幕上‌
‌1. DOM树构建‌ - 解析HTML文档，将标签和文本转换为DOM节点，形成DOM树结构‌
‌2. CSSOM树构建‌ - 解析CSS样式，构建CSS对象模型树‌
‌3. 渲染树构建‌ - 将DOM树和CSSOM树合并，排除隐藏元素，生成渲染树‌
‌4. 布局计算‌ - 计算每个元素在页面中的确切位置和大小‌
‌5. 绘制与合成‌ - 将元素绘制为像素，最终合成显示页面‌
# 浏览器重排与重绘
‌回流（重排）‌：当元素尺寸、位置或结构发生变化时，浏览器需要重新计算布局‌
‌重绘‌：当元素样式改变但不影响布局时，浏览器只重新绘制像素‌
# 浏览器的回收机制
管理代码运行中的内存，垃圾回收机制会定时找出不在继续使用的变量，按后释放内存， 内存如果开销比较大会影响gc，阻塞其他应用程序的执行，他是会按照固定时间周期性的进行执行，通常是两种标记清除和引用计数
标记清除：首先会标记那些对象仍在使用，从根对象出发，标记所有可达对象，然后清除没有标记的对象，进行释放；
引用计数：跟踪每个对象的工作次数，计数将为0 的时候就是内清楚，但是两个对象相互引用的时候，就永远不会为0，会造成内存泄漏；
# 那些情况会内存泄露
1.意外生明的全局变量
2.定时器未清除
3.创建的节点未在，界面卸载移除
4.使用的闭包的大变量
5.对象的循环引用
# 浏览器的缓存机制
缓存机制的优点:
    1.减少对服务器的请求次数，减轻服务器负担，提升网站性能
    2.使用缓存可以加快网页的访问速度
    3.减少冗余数据传输，减少使用网费使用
浏览器分为两种缓存方式：
    * 强制缓存 请求头里会有一个Cache-control
        1.max-age：300s  强缓存
        2.public：允许浏览器、代理服务器 都可以缓存
        3.private：只允许浏览器缓存
        4.no-cache: 禁用强制缓存
        5.no-store: 禁止强缓存和协商缓存，必须从服务器里获取最新的资源
    http1.0里会有expires：有一个绝对过去事件
当我们这个cache-control配置的是no-cache时候就会进入协商缓存
我们的响应头里会有一个Last-modified（资源最新的修改时间，单位是s）
在向服务器发送请求的时候，请求头里会携带一个参数：if-modified-since：它的值就是上一次资源文件修改的时间
服务器在接收参数的时候如果i有if-modified-since，那么服务器就会和上一次修改资源文件的时间作比较
    1.时间相等：服务器返回304，浏览器就会从缓存文件里获取数据
    2.时间小于：服务器就会返回最新数据，状态码200
优化技术：
Etag：如果说响应头，下一次在请求的时候，请求头里会秀娥带一个参数if-none-match，参数的值是一个hash值
hash值会和服务器里的hash值做比较
    1.hash值相等：服务器返回304，浏览器就会从缓存文件里获取数据
    2.不相等：服务器就会返回最新数据，状态码200